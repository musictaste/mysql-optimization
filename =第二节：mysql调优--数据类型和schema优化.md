[TOC]

# schema与数据类型优化(接)

## 合理使用范式和反范式

### 三范式：

1NF的定义为：列不可分；【符合1NF的关系中的每个属性都不可再分】  
2NF：不能存在传递依赖；【保证一张表只描述一件事情】  
3NF：必须唯一的依赖于主键；【保证每列都和主键直接相关】  
**三范式的作用：减少数据冗余**  
——基础课有讲范式

==阿里规范：超过三站表，禁止使用join，为什么==  原因：join过程慢；也得看数据量的大小，数据量少也很快

### 范式
    
    优点  
    	范式化的更新通常比反范式要快  
    	当数据较好的范式化后，很少或者没有重复的数据  
    	范式化的数据比较小，可以放在内存中，操作比较快  
    
    缺点  
    	通常需要进行关联

	
### 反范式

    优点  
    	所有的数据都在同一张表中，可以避免关联  
    	可以设计有效的索引；
    	
    缺点   
    	表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失

### 注意

在企业中很好能做到严格意义上的范式或者反范式，一般需要混合使用

在一个网站实例中，这个网站，允许用户发送消息，并且一些用户是付费用户。现在想查看付费用户最近的10条信息。

在user表和message表中都存储用户类型(account_type)而不用完全的反范式化。这避免了完全反范式化的插入和删除问题，因为即使没有消息的时候也绝不会丢失用户的信息。这样也不会把user_message表搞得太大，**有利于高效地获取数据**。

另一个：**从父表冗余一些数据到子表的理由是排序的需要**。

缓存**衍生值**也是有用的。如果需要显示每个用户发了多少消息（类似论坛的），可以每次执行一个昂贵的自查询来计算并显示它；也可以在user表中建一个num_messages列，每当用户发新消息时更新这个值。

### 案例

==范式设计==
![201](F52E8677E06B47A5BCC4FB34C5371B7D)


==反范式设计==
![202](ED8809A01B044F1EAE88BCEE177D931F)


全排序，意味着需要将数据全部加载到内存中，这个过程非常慢；解决：1.把数据放到一张表中；2.或使用索引，索引底层数据结构是B+树，本身就是有序树，可以按照当前列进行排序，不需要放到内存进行排序

使用了limit不需要使用order by或order by 不生效，原因就是使用了索引的查询

约定大于规范


## 主键的选择

代理主键：例如id；与业务无关的，无意义的数字序列

自然主键：人的身份证号；事物属性中的自然唯一标识

==区分自然、代理主键：是否跟业务相关==

==推荐使用代理主键：==

1. 它们不与业务耦合，因此更容易维护
2. 一个大多数表，最好是全部表，通用的键策略能够减少需要编写的源码数量，减少系统的总体拥有成本

主键生成器：n种生成策略，


## 字符集的选择

字符集直接决定了数据在MySQL中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以**通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少IO操作次数。**

1. **纯拉丁字符**能表示的内容，没必要选择**latin1**之外的其他字符编码，因为这会节省大量的存储空间。
2. 如果我们可以**确定不需要存放多种语言，就没必要非得使用UTF8或者其他UNICODE字符类型**，这回造成大量的存储空间浪费。
3. MySQL的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过对不同表不同字段使用不同的数据类型来较大程度减小数据存储量，进而降低 IO 操作次数并提高缓存命中率。

==中文存储，不建议utf-8；中文有可能是2个或3个字符来存储；建议utf8mb4==

    yum install man man-pages
    man utf8
        #Encoding  不同的范围使用不同的字节来存储
        

gbk不常用，存在什么bug？？？


## 存储引擎的选择



engine默认为InnoDB，如何修改？my.inf -> default-storage-engine=INNODB（windows）

memory不能持久化

==MyISAM 和InnoDB的对比==

![203](192EA054C677408E905916308E36C637)

非聚簇索引、聚簇索引在后面的索引章节会详细讲解

非聚簇索引：索引文件和数据文件不放在一起  
聚簇索引：索引文件和数据文件放在一起

==区分InnoDB是表锁还是行锁？==  
InnoDB存储引擎默认是给索引加锁；所以只需要判断一件事：增删改查的那个列是否是建索引的那个列；如果是索引列，就是行锁；否则为表锁

**全文索引怎么理解？**  
文章content字段，要检索是否有java关键字；一般企业中不会使用全文索引，因为效率低  -》其他方式：lson、solr、ES

==为什么尽量不要使用like？like中有%，那么索引不生效==


存储引擎：数据文件的组织形式，因为组织形式不同，导致数据操作不一样；所以数据操作是跟数据引擎相关的

==存储引擎可以转换吗==？可以，但是需要注意：转换时需要对索引、列也进行转换，这个转换有很多需要注意的点，一般没人这么干

## 适当的数据冗余

1. 被频繁引用且只能通过 Join 2张(或者更多)大表的方式才能得到的独立小字段。
2. 这样的场景由于每次Join仅仅只是为了取得某个小字段的值，Join到的记录又大，**会造成大量不必要的 IO**，完全可以**通过空间换取时间的方式来优化**。不过==冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新==。

**需要更新冗余数据，类似物化视图**



使用视图，需要提前执行sql语句；

==物化视图：oracle有，mysql没有==  

物化视图，把sql执行的结果提前放到一张物理表中；如果基表数据发生变化，那么物化视图也要进行更改；oracle提供两种机制：undemand、uncommit  

uncommit:基表的数据只要提交更新，那物化视图就进行更改  

undemand:对物化视图进行查询的时候，才会对物化视图进行更改


## 适当拆分

当我们的表中存在类似于TEXT或者是很大的VARCHAR类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，**既减少物理 IO 次数，也能大大提高内存中的缓存命中率**。

提到拆分，大家会想到分库分表；分库分表是分两种层次，一种是水平切分【1到1000】、一种是垂直切分【业务切分】

mycat时会详细介绍 -> sharding

业务切分、数据切分是很复杂的

爱奇艺上AWS；舆情系统

数据库字段的拆分是很重要的


# 执行计划

mysql官网 -》 搜explain  ->  explain statement

《mysql执行计划.md》---详细查看文档，如果有问题，可以查看基础视频

    explain select * from user;

==mvcc??==



# 闲聊

oracle服务是收费的，并且是以分钟计费

oracle有专门的法务团队，跟使用盗版的公司打官司，每年的利润是几亿

==慢查询：是mysql非常重要的的核心点，有慢查询日志；开启慢查询，会有慢查询日志，可以根据慢查询日志进行优化==

InnoDB有共享锁和排它锁；共享锁和排它锁不能同时存在

==阿里去IOE（IBM的小型机、Oracle数据库、EMC存储设备），把oracle去掉了==

==《淘宝十年》--建议看==

阿里云现在不使用openStack，现在closedStack？？

==mysql优化，首先要知道哪块执行慢，然后去优化；不能只根据执行计划就去优化==

大云移或大云虚：大数据+云计算+移动化+虚拟化

云计算：现在被各大公司独占；

AWS：如果要使用，需要专门培训

私自搭建VPN，容易被查水表

# 通过索引进行优化

官网 -》 Optimization  ->  Optimization and indexs -》 how mysql uses indexes -> Comparison of B-Tree and hash indexes

纠正官网的说法:说底层使用的B-Tree,但是实际底层使用的B+Tree

想要了解索引的优化方式，必须要对索引的底层原理有所了解

## 索引采用的数据结构 -》 哈希表和B+树

学习数据结构的网站

www.cs.usfca.edu/~galles/visualization/BST.html

www.visualgo.net/zh

www.geeksforgeeks.org


---

==哈希表(存储引擎：Memory) + B+树(存储引擎：InnoDB、MyISAM)==

索引？你打算怎么设计索引？

1.索引要记录什么内容？数据记录在文件中，有偏移量offset-row （cursor、seek）；**索引要记录偏移量**

2.使用什么样的数据结构存在索引？为什么是B+树

### -1：哈希表：memory

数组+链表，进行散列算法（取模运算）

缺点：

1、利用hash存储的话需要将所有的数据文件添加到内存，比较耗费内存空间

2、如果所有的查询都是等值查询，那么hash确实很快，但是在企业或者实际工作环境中范围查找的数据更多，而不是等值查询，因此hash就不太适合了

==注意：如果使用的存储引擎是Memory，那么使用的存储格式就是Hash，因为hash需要将数据全部读取到内存==

### 二叉树发展历程：二叉树-》BST 二叉搜索树  -》AVL平衡树(作者简写)

#### -2：二叉树
![205](2DECA485B6E040D5BC4C4FDAC2360873)

缺点：无论是二叉树还是红黑树，都会因为树的深度过深而造成io次数变多，影响数据读取的效率

==数据倾斜，造成IO成本==


#### -3 二叉搜索树BST
```
二叉搜索树(Binary Search Tree，简写BST)，又称为二叉排序树，属于树的一种，通过二叉树将数据组织起来，树的每个节点都包含了健值 key、数据值 data、左子节点指针、右子节点指针。其中健值 key 是最核心的部分，它的值决定了树的组织形状；数据值 data 是该节点对应的数据，有些场景可以忽略，举个例子，key 为身份证号而 data 为人名，通过身份证号找人名；左子节点指针指向左子节点；右子节点指针指向右子节点。

特点:
    左右子树也分别是二叉搜索树。
    左子树的所有节点 key 值都小于它的根节点的 key 值。
    右子树的所有节点 key 值都大于他的根节点的 key 值。
    二叉搜索树可以为一棵空树。
    一般来说，树中的每个节点的 key 值都不相等，但根据需要也可以将相同的 key 值插入树中
```

#### 左旋+右旋

![204](E7C24F99F4D84B22BF47C4BB7E6BC3AA)

左旋： 逆时针旋转，父节点被自己的右孩子取代，而自己成为自己的左孩子（Y节点的左孩子，变成X节点的右孩子）

右旋：顺时针旋转，父节点被左孩子取代，而自己成为自己的右孩子（把Y节点的右孩子变成X的左孩子）

**保证当前最短子树和最长子树，长度差不能超过1**

**数据越多，需要经过1到N的旋转，旋转会浪费时间、浪费性能**


#### -4 平衡二叉搜索树AVL -》左旋右旋

AVL树，也称平衡二叉搜索树，AVL是其发明者姓名简写。AVL树属于树的一种，而且它也是一棵二叉搜索树，==不同的是他通过一定机制能保证二叉搜索树的平衡，平衡的二叉搜索树的查询效率更高。==

**特点：**

AVL树是一棵二叉搜索树。

AVL树的左右子节点也是AVL树。

AVL树拥有二叉搜索树的所有基本特点。

**每个节点的左右子节点的高度之差的绝对值最多为1，即平衡因子为范围为[-1,1]。**

==缺点：插入效率极低、查询效率高；2.并且树也很深==

#### -5 红黑树

红黑(Red-black)树是一种**自平衡二叉查找树**，1972年由Rudolf Bayer发明，**它与AVL树类似，都在插入和删除操作时能通过旋转操作保持二叉查找树的平**衡，以便能获得高效的查找性能。**它可以在 O(logn) 时间内做查找，插入和删除等操作**。**红黑树是2-3树的一种等同**，但有些红黑树设定只能左边是红树，这种情况就是2-3树的一种等同了。

**对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。**

```
特点：
   节点是红色或黑色。
   根节点是黑色。
   每个叶节点（NIL节点）是黑色的。
   每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
   从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
   最长路径不超过最短路径的2倍
```


由AVL演化出红黑树：**旋转操作+变色功能 两种行为效率**，==加入变色功能，减少旋转次数==

**单分支中不能出现两个连续节点都为红色；每个分支中到达根节点的黑色节点个数必须一致；**

==将插入和查询效率做了平衡，提高插入效率，损失查询效率==

==也会出现节点过深的问题==

##### ==HashMap节点数达到8，并且总体个数达到64时，会转换成红黑树，涉及到查询效率，找HashMap的视频==

##### jdk1.8以后的HashMap存储数据结构:链表长度超过8且数组长度大于64时,数据结构改为了红黑树 -> 涉及到查询效率，找HashMap的视频


HashMap的高效率

**HashMap是将key做hash算法，然后将hash值映射到内存地址，直接获取key所对应的数据**。

HashMap中数据存储的结构是数组+链表，**链表是为了解决hash碰撞问题**。

HashMap为什么快？主要是以下三点：


```
hash算法是高效的；
hash值到内存地址(数组索引)的算法是快速的；
根据内存地址(数组索引)可以直接获取对应的数据。
```

负载因子和阀值

负载因子又叫填充比，**是一个介于0和1之间的浮点数**，他决定了HashMap在扩容之前内部数组的填充度。**默认HashMap初始大小16，负载因子0.75**；

负载因子=元素个数/内部数组总数

在Jdk1.8以及以后的版本中,HashMap的底层数据结构由原来的数组+链表，调整为数组+链表/红黑树

首先明确链表的时间复杂度是O(n),红黑树时间复杂度是O(Logn)。**既然红黑树的复杂度优于链表，那么为为什么HashMap不直接使用红黑树代替链表呢？**

**树的节点占的空间是普通节点的两倍，在节点足够多的时候才会使用树形数据结构**，如果节点变少了还是会变回普通节点。总的来说就是节点太少的时候没必要转换、**不仅转换后的数据结构占空间而且转换也需要花费时间**。

**为了使hashCode分布良好,树形结构很少使用**。并且**在理想状态下受随机分布的hashCode影响**，链表中的节点遵循**泊松分布**，据统计**链表中的节点数是8的概率已经接近千分之一且此时链表的性能已经很差**。所以在这种比较罕见的和极端的情况下才会把链表转变为红黑树。

就是说大部分情况下HashMap还是使用链表，如果理想的均匀分布节点数不到8就已经自动扩容了。

##### 红黑树插入过程

![207](A4EC6D03D5854AF891BA5C922AAC9C21)
![208](373C7E97546E498DA9F59C0C608D4956)
![209](6C124533288D4B1885DED97F31119C47)
![210](DC5D165EE7754D7082222F193B641174)
![211](FE091BE676D34948BAE6BBF953538F6F)
![212](036AA862A2444C4B9498296BD3649C4D)

#### B树

![206](7C684E7D66154E1581DFE4FBDE6AD320)

```
实例图说明：
每个节点占用一个磁盘块，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为 16 和 34，P1 指针指向的子树的数据范围为小于 16，P2 指针指向的子树的数据范围为 16~34，P3 指针指向的子树的数据范围为大于 34。 
查找关键字过程：
1、根据根节点找到磁盘块 1，读入内存。【磁盘 I/O 操作第 1 次】
2、比较关键字 28 在区间（16,34），找到磁盘块 1 的指针 P2。
3、根据 P2 指针找到磁盘块 3，读入内存。【磁盘 I/O 操作第 2 次】
4、比较关键字 28 在区间（25,31），找到磁盘块 3 的指针 P2。
5、根据 P2 指针找到磁盘块 8，读入内存。【磁盘 I/O 操作第 3 次】
6、在磁盘块 8 中的关键字列表中找到关键字 28。 
```

```
B树特点：
1、所有键值分布在整颗树中
2、搜索有可能在非叶子结点结束，在关键字全集内做一次查找,性能逼近二分查找
3、每个节点最多拥有m个子树
4、根节点至少有2个子树
5、分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）
6、所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列
```

优点：**B树减少了IO次数，**

缺点：1、**每个节点都有key，同时也包含data**，而每个页存储空间是有限的，如果data比较大的话会导致每个节点存储的key数量变小

2、**当存储的数据量很大的时候会导致深度较大，增大查询时磁盘io次数，进而影响查询性能**

### B+树
![213](F905C967DB254EEA8049C624DEA43F8D)

B+Tree是在BTree的基础之上做的一种优化，变化如下：

1、**B+Tree每个节点可以包含更多的节点**，这个做的原因有两个，**第一个原因是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快**

2、**非叶子节点存储key，叶子节点存储key和数据**

3、**叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高**


==注意==：**在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点**，而且**所有叶子节点（即数据节点）之间是一种链式环结构**。因此可以对 B+Tree 进行两种查找运算：**一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。**

### B树、B+树支撑的数据量计算

Mysql读数据需要磁盘预读，是page的整数倍，默认读取16K，也就是4 page; **一个磁盘块可以读取16K的数据**，**假设索引不占用空间，而每一条数据占用空间1Kb**，那么一个磁盘块最多只能读取16条数据；那么**三层B树可以读取的数据=16*16*16=4096条数据**

**非叶子节点存储了过多的data数据**

而Mysql中一般由几百万条数据；磁盘块大部分的空间用于存储data数据，这时候优化：磁盘块中不存储data数据，只在叶子节点存储数据；

**B+树在B树的基础上做了优化：非叶子节点不再存储data数据，只存储key和指针**

==非叶子节点 16Kb,而每一个key的空间为10b，那么一个非叶子节点的磁盘块可以存储 16*100=1600条数据；那么三层的B+树，1600 * 1600 * 16=40960000，可以支撑千万级的数据量==

### B*树 -》在B+树的非叶子节点之间也建立了指针

### B+树在Mysql中应用

#### InnoDB

==注意==：1、InnoDB是通过**B+Tree结构对主键创建索引，然后叶子节点中存储记录**，**如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个6位的row_id来作为主键**;2、==如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录,叫做回表==


#### MYISAM
![215](48F29441D01E49C9834A29F8991B386B)

### 小结：

存储引擎InnoDB: .idb  ==数据和索引在一个文件中； 叶子节点中存储的是一整行的数据==，是聚簇索引

MYISAM:  .MYD   .MYI  ==数据和索引分开存放的；叶子节点存放的是实际数据所在文件的地址，需要先从叶子节点中拿到地址，再到数据文件中根据地址读取数据==，是非聚簇索引；这样MyISAM多了一次IO，所以我们经常使用InnoDB

==Mysql的查询速率是很快的；那么我们使用Mysql慢的原因是：IO、并发请求（并发请求多了，意味着有很多份缓存，内存不够，需要频繁替换内存，也就是吞吐量不够）==

Mysql8.X剔除了查询缓存（因为查询缓存经常更新，命中率也低，不常使用）

## 索引优点

1、大大减少了服务器需要扫描的数据量

2、**帮助服务器避免排序和临时表** 
    
order by 使用的是全排列，需要将全量数据加载到内存那种；-》应该使用索引

3、**将随机io变成顺序io** -》 之前讲过kafka的例子？



## 索引用处

官网直接翻译


1、快速查找匹配WHERE子句的行

2、从consideration中消除行,如果可以在多个索引之间进行选择，mysql通常会使用找到最少行的索引

prosibly keys中使用找到最少行的索引
    
3、如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行

4、当有表连接的时候，从其他表检索行数据

5、**查找特定索引列的min或max值**

6、**如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组**

7、在某些情况下，可以优化查询**以检索值而无需查询数据行**


## 索引分类


主键索引

唯一索引

普通索引

**全文索引**：应用在varchar、char类型中

组合索引


**问题1：数据库会帮我们默认建索引吗？会**

问题2：数据库会为哪些列建索引？  ==特别注意：是唯一键（不是主键，主键也是唯一键）==


## 面试技术名称（常问）

### 回表：

我们可以给主键建立索引，也可以给普通列建立索引；**注意：普通索引的叶子节点中存放的是该列的主键，不是整行数据；**

==所以普通索引的过程是：1.先查找name的索引树(B+树)，找到主键id；2.再到主键id的索引树（B+树）中，找到整行数据，这个过程就是回表==

### 覆盖索引：

select * from emp where name=1，普通索引，需要先查找普通列的B+树，得到主键id再去查找主键id的B+树；

而现在sql语句变为：select id from emp where name=1,不需要根据再去主键的B+树查找整行数据得到id了；这样就没有回表了，也就是覆盖索引

覆盖索引：select * from emp where name=1  -》  select id from emp where name=1

==覆盖索引：select id,name frome emp where name=1==

不是覆盖索引：select id，age from emp where name=1

==覆盖索引的局限性还是很大的，但是在组合索引时使用还是比较多的，并且能用覆盖索引，尽量使用覆盖索引==


### 最左匹配：--》存在于组合索引

如果查询时经常用到name/age,那么我们会建立一个索引：name+age

现在有一个sql：select * from emp where name=? and age=?，这个语句可以使用上面建立的索引

sql:select * from emp where age=? ,这个语句不能使用上面建立的索引

**最左匹配：查询条件必须先匹配索引的左边**

---

**问题：现在有索引name+age,“ select * from emp where age=? ”这个sql如何优化**

方案一：建立组合索引：age+name  -》 **更优：因为可以匹配查询条件：age,也可以匹配查询条件：age+name**

方案二：建立索引：age

方案三：sql查询条件更换位置  -》 不起作用

**注意：select * from emp where name=? and age=?不会有效果，因为mysql优化器会调整age和name的顺序**


---

问题：下面三条sql语句，应该如何建索引？


```
select * from emp where name=? and age=?

select * from emp where age=?

select * from emp where name=?
```


**第一种：name+age , age (选这个)**

**因为age数据占用空间更小，IO查询次数较少，IO损耗更小**

第二种：age+name ,name 

第三种：age,name


---

索引合并：低版本没有索引合并，默认情况下只能用一个索引；高版本有索引合并，但是是由优化器完成的，多一个优化的步骤，效率不一定高

索引合并？？

索引页分裂、索引页合并？？

### 索引下推：

**谓词下推**：

select t1.name,t2.name from t1 join t2 on t1.id=t2.id

第一种方案：把t1/t2所有的列都加载的内存中，然后取name,id

**第二种方案：把t1.id/name, t2.id/name加载到内存中，这种就是谓词下推**

---

索引下推：select name,age from table where name=? and age=?

第一种方式：想将name=?的数据从存储引擎中取出来，在server这一层，再匹配age=？的数据

第二种方式：**根据name=?+age=?的数据从存储引擎中取出来**

索引条件 可以减少存储引擎查询基础表的次数，也可以减少server层从存储引擎接收数据的次数

==索引下推的前提是组合索引==

### 主键索引和唯一索引的区别

**一个区别：主键索引不能为空，唯一索引可以为空**

**空值的比较会慢一点，所以一般不建议为空**

**查询效率是一样的**

# 如何学习后防止遗忘

学习方法：学习的时候要记录好笔记，多复习

复习的时候：【先根据已有的印象去画，然后不停补充；知识点有关联

根据脑中的知识点画思维导图，尽量细；如果后面有新的知识点再补进去，并且每个知识点如果有联系，要连线；

以后再学新的知识点，就可以很快关联想到很多知识点

思维导图画的越乱越有帮助





