[TOC]

# 索引基本知识

## 索引匹配方式-6种范围（一定记住）

官网-》ducumentation -> more  -> Example Databases -> 有employee data/world database/sakila database/menagerie database  -> view  ->5 Structure

四个数据库，里面的数据可以直接导入使用，并且官方的很多sql都是基于这四个数据库的

使用sakila database，导入-data.sql/-schema.sql

    source /root/sakila-data.sql
    source /root/sakila-schema.sql

文档《sakila数据库说明.md》


```
create table staffs(
    id int primary key auto_increment,
    name varchar(24) not null default '' comment '姓名',
    age int not null default 0 comment '年龄',
    pos varchar(20) not null default '' comment '职位',
    add_time timestamp not null default current_timestamp comment '入职时间'
  ) charset utf8 comment '员工记录表';

-----------alter table staffs add index idx_nap(name, age, pos);

show index from staffs;

```

### 全值匹配
 
```
全值匹配指的是和索引中的所有列进行匹配
explain select * from staffs where name = 'July' and age = '23' and pos = 'dev';
执行结果：注意：possible_keys  key  ref  rows【只是预估值】
```

### 匹配最左前缀

```
只匹配前面的几列
	explain select * from staffs where name = 'July' and age = '23';
	explain select * from staffs where name = 'July';
```

### 匹配列前缀

```
可以匹配某一列的值的开头部分
	explain select * from staffs where name like 'J%';
	explain select * from staffs where name like '%y';
```

### 匹配范围值

```
可以查找某一个范围的数据
	explain select * from staffs where name > 'Mary';
```

### 精确匹配某一列并范围匹配另外一列

```
可以查询第一列的全部和第二列的部分
	explain select * from staffs where name = 'July' and age > 25;
```

### 只访问索引的查询 -> 本质上就是覆盖索引

```
查询的时候只需要访问索引，不需要访问数据行，本质上就是覆盖索引
	explain select name,age,pos from staffs where name = 'July' and age = 25 and pos = 'dev';
```


# 哈希索引（面试问的很少，掌握核心点就可以）

基于哈希表的实现，只有**精确匹配**索引所有列的查询才有效

==在mysql中，只有memory的存储引擎显式支持哈希索引==

**哈希索引自身只需存储对应的hash值，所以索引的结构十分紧凑，这让哈希索引查找的速度非常快**

## 哈希索引的限制


1、**哈希索引只包含哈希值和行指针，而不存储字段值**，索引不能使用索引中的值来避免读取行

**数据查找：哈希值-》行指针-》行数据,因为在内存中执行，所以比较快**

2、哈希索引数据**并不是按照索引值顺序存储的，所以无法进行排序**

插入数据的顺序，跟存储顺序不一致，所以无法进行排序
    
3、哈希索引**不支持部分列匹配查**找，哈希索引是使用索引列的全部内容来计算哈希值

如果只支持部分列匹配的话，无法根据哈希值找到对应的数据

4、哈希索引支持等值比较查询，也**不支持任何范围查询**
    
5、访问哈希索引的数据非常快，除非有很多哈希冲突，**当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行**
    
    如何避免哈希冲突：编写优秀的哈希算法
    hashmap偷懒的方式：用数组长度取模--》这种方式禁用
    
    因为如果数据长度是16，那么只需要看低4位，那么可能出现低4位相同，高4位不相同，那么导致每次的值都会哈希冲突
    
    所以，在JDK的hashmap中有扰动函数,这样就可以高位参与运算，而不是低位参与运算
    
    如果哈希冲突严重的话，会导致链表无限长，那么查找时只能顺序按个查找，这样就变成了链表，而链表的时间复杂度比较低，所以尽量避免哈希冲突

6、**哈希冲突比较多的话，维护的代价也会很高**

## 案例

当需要存储大量的URL，并且根据URL进行搜索查找，如果使用B+树，存储的内容就会很大

select id from url where url=""

也可以利用将url使用CRC32做哈希，可以使用以下查询方式：

select id fom url where url="" and url_crc=CRC32("")

此查询性能较高原因是使用体积很小的索引来完成查找

---

### CRC32：循环冗余校验算法


CRC32：循环冗余校验算法   一种hash算法，大数据项目，存储hbase的roukey时使用CRC32

**将很长字符串通过CRC32得到指定长度的整数值，再根据整数值再进行哈希算法**

使用了较小的索引，B+树的深度就会变小，减少了IO次数，从而提供了性能

==哈希索引的应用：当存储索引需要占用很多空间的时候，使用哈希索引==

**哈希索引的缺点就是无法持久化，重启就没有了**

公司中很少用到memory，只是面试中会问到

**有一个常量表有几百万行数据，并且很少修改，别的表又经常用到这个常量表，会将这个常量表使用memory存储引擎，使用hash索引；注意：数据不能频繁修改**

但是一般来说常量值不会太多，所以也不会用到哈希索引

## 面试题：如何避免哈希冲突问题？ -> 编写优秀的哈希算法

# 组合索引

当包含多个列作为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要

案例，建立组合索引a,b,c
	
不同SQL语句使用索引情况

![301](B1C50312AA1148CC939E89B7C9EE398F)

# 聚簇索引与非聚簇索引

## 聚簇索引-》 主键索引

**不是单独的索引类型，而是一种数据存储方式**，指的是数据行跟相邻的键值紧凑的存储在一起

==注意：只有主键才会和数据放在一起，如果不是主键索引，索引跟数据不会在一起，所以数据不会存放多份==
		
### 优点

1、可以把相关数据保存在一起

2、**数据访问更快，因为索引和数据保存在同一个树中**

3、**使用覆盖索引扫描的查询可以直接使用页节点中的主键值**


### 缺点

1、**聚簇数据最大限度地提高了IO密集型应用的性能**，**如果数据全部在内存，那么聚簇索引就没有什么优势**

2、**插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式**

3、**更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置**

4、==基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题==

5、==聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候==

#### 怎么理解？页分裂、页合并

如果插入数据，维护索引时，对应磁盘块(数据页)的正好满了，要发生页分裂：原来的磁盘块扩展为两个磁盘块；原先磁盘块的数据**等分**为两份，上一半数据在第一个磁盘，后一半数据在第二个磁盘；这时候**两个磁盘块的空间没有充分利用，空间利用率不高，并且还会降低查询速度**

如果删除数据，维护相应的索引，如果两个磁盘块的数据总量不够一个磁盘块的容量，就会触发页合并：**两个数据页合并为一个数据页**

==页分裂、页合并 都会触发磁盘IO，索引的维护会更高，影响查询的执行效率==

类似大数据中的HBase的region分割

## 非聚簇索引

**数据文件跟索引文件分开存放**

暂时不清楚非聚簇索引的优缺点

# 问题：如果现在需要大量数据的Mysql迁移，应该怎么迁移？

导数据之前，先将索引关闭；数据迁移以后再将索引打开

为什么？避免数据迁移过程中，一边导数据一边建索引，频繁的操作索引，导致迁移速度变慢


# 覆盖索引


**覆盖索引只是一种现象，不是索引类型**

**除了InnoDB，MyISAM也是支持覆盖索引**（普通索引 存放的是 数据的地址值，根据地址值找到主键值），但是MyISAM中覆盖索引使用并不多

==IO密集型：数据库==

## 基本介绍

1、**如果一个索引包含所有需要查询的字段的值，我们称之为覆盖索引**
2、不是所有类型的索引都可以称为覆盖索引，覆盖索引必须要存储索引列的值
3、不同的存储实现覆盖索引的方式不同，不是所有的引擎都支持覆盖索引，**memory不支持覆盖索引**


## 优势

1、索引条目通常远小于数据行大小，如果只需要读取索引，那么mysql就会极大的**减少数据访问量**

2、因为**索引是按照列值顺序存储的**，所以对于**IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多**

3、一些存储引擎如MYISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用，这可能会导致严重的性能问题

4、由于INNODB的聚簇索引，**覆盖索引对INNODB表特别有用**

## 案例演示：覆盖索引.md

1.当发起一个被索引覆盖的查询时，在explain的**extra列可以看到using index的信息**，此时就使用了覆盖索引

2、在大多数存储引擎中，覆盖索引**只能覆盖那些只访问索引中部分列的查询**。不过，可以进一步的进行**优化，可以使用innodb的二级索引(也就是非聚簇索引)来覆盖查询**。


# 优化小细节

## 1.当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层

==需要知道的优先级：system > const > ref > range > index > all==

通过对比两条sql语句的执行计划 ，可以清楚明白

```
select actor_id from actor where actor_id=4; //const
select actor_id from actor where actor_id+1=5; //index
```

## 2.尽量使用主键查询，而不是其他索引，因此主键查询不会触发回表查询

因为查询条件有主键，会触发主键索引；尽量使用索引查找，要不有可能触发all全表扫描

## 3.使用前缀索引

### 《前缀索引实例说明》

**有时候需要索引很长的字符串，这会让索引变的大且慢**，通常情况下**可以使用某个列开始的部分字符串**，这样大大的节约索引空间，从而提高索引效率，但这会**降低索引的选择性**，**索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1/#T到1之间**。**索引的选择性越高则查询效率越高**，因为选择性更高的索引可以让mysql在查找的时候过滤掉更多的行。

​		一般情况下某个列前缀的选择性也是足够高的，足以满足查询的性能，但是==对应BLOB,TEXT,VARCHAR类型的列，必须要使用前缀索引==，因为mysql不允许索引这些列的完整长度，==使用该方法的诀窍在于要选择足够长的前缀以保证较高的选择性，并且又不能太长==。

注意：前缀索引是一种能使索引更小更快的有效方法，但是也包含缺点：**mysql无法使用前缀索引做order by 和 group by**。 


```
--查找最常见的城市列表，发现每个值都出现45-65次，
select count(*) as cnt,city from citydemo group by city order by cnt desc limit 10;

--查找最频繁出现的城市前缀，先从3个前缀字母开始，发现比原来出现的次数更多，可以分别截取多个字符查看城市出现的次数
select count(*) as cnt,left(city,3) as pref from citydemo group by pref order by cnt desc limit 10;
select count(*) as cnt,left(city,7) as pref from citydemo group by pref order by cnt desc limit 10;
--此时前缀的选择性接近于完整列的选择性

还可以通过另外一种方式来计算完整列的选择性，可以看到当前缀长度到达7之后，再增加前缀长度，选择性提升的幅度已经很小了
select count(distinct left(city,3))/count(*) as sel3,
count(distinct left(city,4))/count(*) as sel4,
count(distinct left(city,5))/count(*) as sel5,
count(distinct left(city,6))/count(*) as sel6,
count(distinct left(city,7))/count(*) as sel7,
count(distinct left(city,8))/count(*) as sel8 
from citydemo;

--计算完成之后可以创建前缀索引
alter table citydemo add key(city(7));
```


### 扩展：cardinality基数（在OLAP联机系统里面是必问的知识点）

show index from citydemo; # 有属性cardinality

cardinality 基数，在OLAP联机系统里面是必问的知识点


OLAP对历史数据做整体分析（有一个10年的网站，历史数据很多，使用OLAP对历史数据做分析，用作广告投放、或影响决策等）

数据库叫OLTP

问题：表A join 表B,有一个列C；有100万条数据，但是重复的值只有2个；还有一个列D：重复的值有1000个；现在表A join 表B时，使用列C和列D都可以，你会选择哪个列进行join？

    选C，单个列中的值做一个基数统计，也就是：某个列唯一的值由多少个
    
**某一列中去重的唯一值就是基数**

基数不需要精确，只需要能大概体现值的大小就可以

    show index from citydemo;  # cardinality=596
    select count(distinct city) from citydemo  #599


基数越小，重复数据越多，检索、关联数据，效率会高

**hyperloglog算法会用到基数**

**apache Kylin也会用到基数**

==学习技巧：学习知识要学会关联==

### 作业：查基数、hyperloglog算法

## 4.使用索引扫描来排序

```
explain select * from actor order by first_name; # Extra=using filesort 使用文件进行排序，没有使用索引进行排序
    
explain select * from actor order by actor_id; # Extra=NULL 使用索引进行排序
```

mysql有两种方式可以生成有序的结果：**通过排序操作或者按索引顺序扫描**，**如果explain出来的type列的值为index,则说明mysql使用了索引扫描来做排序**

扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那么就不得不**每扫描一条索引记录就得回表查询一次对应的行，这基本都是随机IO**，因此==按索引顺序读取数据的速度通常要比顺序地全表扫描慢==

**mysql可以使用同一个索引即满足排序，又用于查找行**，如果可能的话，设计索引时应该尽可能地同时满足这两种任务。

**只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方式都一样时，mysql才能够使用索引来对结果进行排序**；**如果查询需要关联多张表，则只有当orderby子句引用的字段全部为第一张表时，才能使用索引做排序**。order by子句和查找型查询的限制是一样的，**需要满足索引的最左前缀的要求**，否则，mysql都需要执行顺序操作，而无法利用索引排序


### 总结

**总结：在使用排序的时候，如果where条件和order by中的一些列能够组成一个最左前缀匹配的话，它就会使用索引排序**

**第一种情况：如果where是范围的话，不能使用索引排序**

**第二种情况：如果order by中的顺序跟索引中排序不一样的话，也不能使用**

**组合索引，默认是升序排序；所以后面的排序必须是组合索引的排序是一模一样的；如果排序不一样，那么无法使用索引进行排序了**

**所以，在进行排序操作的时候，要注意一件事：如果排序列是索引的话，会使用索引排序；如果不是索引的话，会使用文件或临时表空间来进行排序的话，IO量是非常大的，性能是比较低的**

    
### order by需要全量加载数据，比较浪费内存；那么如何不浪费额外内存进行排序呢？ -》 使用索引扫描

### 索引本身就是有序的，所以利用索引进行排序，那么怎么排序呢？ -》 使用索引扫描

    
# 面试题：现在有1T的数据文件，有n行数据，内存只有256M，能否进行排序？如何排序？

大数据hadoop时，分而治之+归并的思想：将数据切分为多个小块，每个小块都能加载到内存中，然后进行排序


